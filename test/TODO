/* cout << "* Split reads-from:\n"
         << solver.solve("test/split1.cat", "test/split2.cat") << endl; // */
    // solver.solve("test/uniproc121.cat", "test/uniproc221.cat");
    // solver.solve({make_shared<ProofNode>("(po-loc;data) & id", "po-loc")});
/* solver.theory.insert(uniproc);
solver.solve({make_shared<ProofNode>("((rf & int);data) & id", "0")}); //+ // */
/* cout << "* rf+ <= rf:\n"
     << solver.solve({make_shared<ProofNode>("rf+", "rf")}) << endl; // */

    // solver.solve({make_shared<ProofNode>("po-loc;po-loc", "po-loc")});

    // TODO: solver.solve("cat/tso.cat", "cat/aarch64-modified.cat");
    // solver.solve("cat/sc.cat", "cat/aarch64-modified.cat");

    // TODO: refactor: tests();
/*string name = "d";
Solver testSolver;
shared_ptr<ProofNode> ab = make_shared<ProofNode>();
ab->left = {Relation::get("a")};
ab->right = {Relation::get("b")};
shared_ptr<ProofNode> bc = make_shared<ProofNode>();
bc->left = {Relation::get("b")};
bc->right = {Relation::get("c")};
testSolver.theory = {ab, bc};*/

    // test(testSolver, name);

    // solver.solve("test/lemma1.cat", "test/lemma2.cat");
/*solver.solve("test/unlemma1.cat", "test/unlemma2.cat");
solver.solve("test/unlemma1.cat", "test/unlemma2.cat");*/